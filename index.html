<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kinh D·ªãch AI</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Serif:ital,wght@0,400;0,700;1,400&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="index.css" />
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚òØÔ∏è</text></svg>">
  <script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.22.0",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
  <!-- Load Babel to transpile JSX/TSX in the browser -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
  <body>
    <div id="root"></div>
    
    <!-- Application source code is placed in a data script block to be processed manually -->
    <script type="text/tsx-app" id="app-source">
      import React, { useState, useEffect, useMemo } from 'react';
      import { createRoot } from 'react-dom/client';
      import { GoogleGenAI, Type } from "@google/genai";

      // --- TYPES AND CONSTANTS ---

      const API_KEY = "AIzaSyBuftqK-NbV-LtSyiuFvkrUO21ixP-Z--Y";

      type LineValue = 6 | 7 | 8 | 9;
      type Trigram = 'C√†n' | 'Kh·∫£m' | 'C·∫•n' | 'Ch·∫•n' | 'T·ªën' | 'Ly' | 'Kh√¥n' | 'ƒêo√†i';

      interface HexagramData {
        number: number;
        hanTu: string;
        vietnameseName: string;
      }

      interface CastingResult {
        question: string;
        method: 'C·ªè Thi' | 'Mai Hoa';
        lines: LineValue[];
        primaryHexagram: HexagramData;
        transformedHexagram: HexagramData | null;
        movingLinesIndices: number[];
      }

      interface AiInterpretation {
        title: string;
        summary: string;
        detailedAnalysis: {
          primaryHexagram: string;
          transformedHexagram: string;
        };
        actionableAdvice: string[];
      }

      interface HistoryEntry extends CastingResult {
        id: string;
        date: string;
        aiInterpretation: AiInterpretation;
      }

      const trigramMap: { [key: string]: Trigram } = {
        '111': 'C√†n', '010': 'Kh·∫£m', '100': 'C·∫•n', '001': 'Ch·∫•n',
        '110': 'T·ªën', '101': 'Ly', '000': 'Kh√¥n', '011': 'ƒêo√†i'
      };

      const trigramToNumber: { [key in Trigram]: number } = {
        'C√†n': 1, 'ƒêo√†i': 2, 'Ly': 3, 'Ch·∫•n': 4,
        'T·ªën': 5, 'Kh·∫£m': 6, 'C·∫•n': 7, 'Kh√¥n': 8
      };

      const HEXAGRAM_DATA: HexagramData[] = [
          { number: 1, hanTu: "‰∑Ä", vietnameseName: "Thu·∫ßn C√†n" }, { number: 2, hanTu: "‰∑Å", vietnameseName: "Thu·∫ßn Kh√¥n" },
          { number: 3, hanTu: "‰∑Ç", vietnameseName: "Th·ªßy L√¥i Tru√¢n" }, { number: 4, hanTu: "‰∑É", vietnameseName: "S∆°n Th·ªßy M√¥ng" },
          { number: 5, hanTu: "‰∑Ñ", vietnameseName: "Th·ªßy Thi√™n Nhu" }, { number: 6, hanTu: "‰∑Ö", vietnameseName: "Thi√™n Th·ªßy T·ª•ng" },
          { number: 7, hanTu: "‰∑Ü", vietnameseName: "ƒê·ªãa Th·ªßy S∆∞" }, { number: 8, hanTu: "‰∑á", vietnameseName: "Th·ªßy ƒê·ªãa T·ª∑" },
          { number: 9, hanTu: "‰∑à", vietnameseName: "Phong Thi√™n Ti·ªÉu S√∫c" }, { number: 10, hanTu: "‰∑â", vietnameseName: "Thi√™n Tr·∫°ch L√Ω" },
          { number: 11, hanTu: "‰∑ä", vietnameseName: "ƒê·ªãa Thi√™n Th√°i" }, { number: 12, hanTu: "‰∑ã", vietnameseName: "Thi√™n ƒê·ªãa Bƒ©" },
          { number: 13, hanTu: "‰∑å", vietnameseName: "Thi√™n H·ªèa ƒê·ªìng Nh√¢n" }, { number: 14, hanTu: "‰∑ç", vietnameseName: "H·ªèa Thi√™n ƒê·∫°i H·ªØu" },
          { number: 15, hanTu: "‰∑é", vietnameseName: "ƒê·ªãa S∆°n Khi√™m" }, { number: 16, hanTu: "‰∑è", vietnameseName: "L√¥i ƒê·ªãa D·ª±" },
          { number: 17, hanTu: "‰∑ê", vietnameseName: "Tr·∫°ch L√¥i T√πy" }, { number: 18, hanTu: "‰∑ë", vietnameseName: "S∆°n Phong C·ªï" },
          { number: 19, hanTu: "‰∑í", vietnameseName: "ƒê·ªãa Tr·∫°ch L√¢m" }, { number: 20, hanTu: "‰∑ì", vietnameseName: "Phong ƒê·ªãa Quan" },
          { number: 21, hanTu: "‰∑î", vietnameseName: "H·ªèa L√¥i Ph·ªá H·∫°p" }, { number: 22, hanTu: "‰∑ï", vietnameseName: "S∆°n H·ªèa B√≠" },
          { number: 23, hanTu: "‰∑ñ", vietnameseName: "S∆°n ƒê·ªãa B√°c" }, { number: 24, hanTu: "‰∑ó", vietnameseName: "ƒê·ªãa L√¥i Ph·ª•c" },
          { number: 25, hanTu: "‰∑ò", vietnameseName: "Thi√™n L√¥i V√¥ V·ªçng" }, { number: 26, hanTu: "‰∑ô", vietnameseName: "S∆°n Thi√™n ƒê·∫°i S√∫c" },
          { number: 27, hanTu: "‰∑ö", vietnameseName: "S∆°n L√¥i Di" }, { number: 28, hanTu: "‰∑õ", vietnameseName: "Tr·∫°ch Phong ƒê·∫°i Qu√°" },
          { number: 29, hanTu: "‰∑ú", vietnameseName: "Thu·∫ßn Kh·∫£m" }, { number: 30, hanTu: "‰∑ù", vietnameseName: "Thu·∫ßn Ly" },
          { number: 31, hanTu: "‰∑û", vietnameseName: "Tr·∫°ch S∆°n H√†m" }, { number: 32, hanTu: "‰∑ü", vietnameseName: "L√¥i Phong H·∫±ng" },
          { number: 33, hanTu: "‰∑†", vietnameseName: "Thi√™n S∆°n ƒê·ªôn" }, { number: 34, hanTu: "‰∑°", vietnameseName: "L√¥i Thi√™n ƒê·∫°i Tr√°ng" },
          { number: 35, hanTu: "‰∑¢", vietnameseName: "H·ªèa ƒê·ªãa T·∫•n" }, { number: 36, hanTu: "‰∑£", vietnameseName: "ƒê·ªãa H·ªèa Minh Di" },
          { number: 37, hanTu: "‰∑§", vietnameseName: "Phong H·ªèa Gia Nh√¢n" }, { number: 38, hanTu: "‰∑•", vietnameseName: "H·ªèa Tr·∫°ch Khu√™" },
          { number: 39, hanTu: "‰∑¶", vietnameseName: "Th·ªßy S∆°n Ki·ªÉn" }, { number: 40, hanTu: "‰∑ß", vietnameseName: "L√¥i Th·ªßy Gi·∫£i" },
          { number: 41, hanTu: "‰∑®", vietnameseName: "S∆°n Tr·∫°ch T·ªën" }, { number: 42, hanTu: "‰∑©", vietnameseName: "Phong L√¥i √çch" },
          { number: 43, hanTu: "‰∑™", vietnameseName: "Tr·∫°ch Thi√™n Qu·∫£i" }, { number: 44, hanTu: "‰∑´", vietnameseName: "Thi√™n Phong C·∫•u" },
          { number: 45, hanTu: "‰∑¨", vietnameseName: "Tr·∫°ch ƒê·ªãa T·ª•y" }, { number: 46, hanTu: "‰∑≠", vietnameseName: "ƒê·ªãa Phong ThƒÉng" },
          { number: 47, hanTu: "‰∑Æ", vietnameseName: "Tr·∫°ch Th·ªßy Kh·ªën" }, { number: 48, hanTu: "‰∑Ø", vietnameseName: "Th·ªßy Phong T·ªânh" },
          { number: 49, hanTu: "‰∑∞", vietnameseName: "Tr·∫°ch H·ªèa C√°ch" }, { number: 50, hanTu: "‰∑±", vietnameseName: "H·ªèa Phong ƒê·ªânh" },
          { number: 51, hanTu: "‰∑≤", vietnameseName: "Thu·∫ßn Ch·∫•n" }, { number: 52, hanTu: "‰∑≥", vietnameseName: "Thu·∫ßn C·∫•n" },
          { number: 53, hanTu: "‰∑¥", vietnameseName: "Phong S∆°n Ti·ªám" }, { number: 54, hanTu: "‰∑µ", vietnameseName: "L√¥i Tr·∫°ch Quy Mu·ªôi" },
          { number: 55, hanTu: "‰∑∂", vietnameseName: "L√¥i H·ªèa Phong" }, { number: 56, hanTu: "‰∑∑", vietnameseName: "H·ªèa S∆°n L·ªØ" },
          { number: 57, hanTu: "‰∑∏", vietnameseName: "Thu·∫ßn T·ªën" }, { number: 58, hanTu: "‰∑π", vietnameseName: "Thu·∫ßn ƒêo√†i" },
          { number: 59, hanTu: "‰∑∫", vietnameseName: "Phong Th·ªßy Ho√°n" }, { number: 60, hanTu: "‰∑ª", vietnameseName: "Th·ªßy Tr·∫°ch Ti·∫øt" },
          { number: 61, hanTu: "‰∑º", vietnameseName: "Phong Tr·∫°ch Trung Phu" }, { number: 62, hanTu: "‰∑Ω", vietnameseName: "L√¥i S∆°n Ti·ªÉu Qu√°" },
          { number: 63, hanTu: "‰∑æ", vietnameseName: "Th·ªßy H·ªèa K√Ω T·∫ø" }, { number: 64, hanTu: "‰∑ø", vietnameseName: "H·ªèa Th·ªßy V·ªã T·∫ø" }
      ];

      const hexagramLookup = new Map(HEXAGRAM_DATA.map(h => [h.vietnameseName, h]));

      // --- HELPER FUNCTIONS ---

      const getLineType = (value: LineValue): 'yang' | 'yin' => (value === 7 || value === 9) ? 'yang' : 'yin';
      const isMovingLine = (value: LineValue): boolean => value === 6 || value === 9;

      const getHexagramFromLines = (lines: ('yang' | 'yin')[]): HexagramData | undefined => {
          if (lines.length !== 6) return undefined;
          const lowerTrigramKey = lines.slice(0, 3).map(l => l === 'yang' ? '1' : '0').join('');
          const upperTrigramKey = lines.slice(3, 6).map(l => l === 'yang' ? '1' : '0').join('');
          
          const lowerTrigram = trigramMap[lowerTrigramKey];
          const upperTrigram = trigramMap[upperTrigramKey];

          const fullHexagramMap = {
              "Kh√¥n-Kh√¥n": "Thu·∫ßn Kh√¥n", "Kh√¥n-Ch·∫•n": "ƒê·ªãa L√¥i Ph·ª•c", "Kh√¥n-Kh·∫£m": "ƒê·ªãa Th·ªßy S∆∞", "Kh√¥n-C·∫•n": "ƒê·ªãa S∆°n Khi√™m",
              "Ch·∫•n-Kh√¥n": "L√¥i ƒê·ªãa D·ª±", "Ch·∫•n-Ch·∫•n": "Thu·∫ßn Ch·∫•n", "Ch·∫•n-Kh·∫£m": "L√¥i Th·ªßy Gi·∫£i", "Ch·∫•n-C·∫•n": "L√¥i S∆°n Ti·ªÉu Qu√°",
              "Kh·∫£m-Kh√¥n": "Th·ªßy ƒê·ªãa T·ª∑", "Kh·∫£m-Ch·∫•n": "Th·ªßy L√¥i Tru√¢n", "Kh·∫£m-Kh·∫£m": "Thu·∫ßn Kh·∫£m", "Kh·∫£m-C·∫•n": "Th·ªßy S∆°n Ki·ªÉn",
              "C·∫•n-Kh√¥n": "S∆°n ƒê·ªãa B√°c", "C·∫•n-Ch·∫•n": "S∆°n L√¥i Di", "C·∫•n-Kh·∫£m": "S∆°n Th·ªßy M√¥ng", "C·∫•n-C·∫•n": "Thu·∫ßn C·∫•n",
              "Kh√¥n-T·ªën": "ƒê·ªãa Phong ThƒÉng", "Kh√¥n-Ly": "ƒê·ªãa H·ªèa Minh Di", "Kh√¥n-ƒêo√†i": "ƒê·ªãa Tr·∫°ch L√¢m", "Kh√¥n-C√†n": "ƒê·ªãa Thi√™n Th√°i",
              "Ch·∫•n-T·ªën": "L√¥i Phong H·∫±ng", "Ch·∫•n-Ly": "L√¥i H·ªèa Phong", "Ch·∫•n-ƒêo√†i": "L√¥i Tr·∫°ch Quy Mu·ªôi", "Ch·∫•n-C√†n": "L√¥i Thi√™n ƒê·∫°i Tr√°ng",
              "Kh·∫£m-T·ªën": "Th·ªßy Phong T·ªânh", "Kh·∫£m-Ly": "Th·ªßy H·ªèa K√Ω T·∫ø", "Kh·∫£m-ƒêo√†i": "Th·ªßy Tr·∫°ch Ti·∫øt", "Kh·∫£m-C√†n": "Th·ªßy Thi√™n Nhu",
              "C·∫•n-T·ªën": "S∆°n Phong C·ªï", "C·∫•n-Ly": "S∆°n H·ªèa B√≠", "C·∫•n-ƒêo√†i": "S∆°n Tr·∫°ch T·ªën", "C·∫•n-C√†n": "S∆°n Thi√™n ƒê·∫°i S√∫c",
              "T·ªën-Kh√¥n": "Phong ƒê·ªãa Quan", "T·ªën-Ch·∫•n": "Phong L√¥i √çch", "T·ªën-Kh·∫£m": "Phong Th·ªßy Ho√°n", "T·ªën-C·∫•n": "Phong S∆°n Ti·ªám",
              "Ly-Kh√¥n": "H·ªèa ƒê·ªãa T·∫•n", "Ly-Ch·∫•n": "H·ªèa L√¥i Ph·ªá H·∫°p", "Ly-Kh·∫£m": "H·ªèa Th·ªßy V·ªã T·∫ø", "Ly-C·∫•n": "H·ªèa S∆°n L·ªØ",
              "ƒêo√†i-Kh√¥n": "Tr·∫°ch ƒê·ªãa T·ª•y", "ƒêo√†i-Ch·∫•n": "Tr·∫°ch L√¥i T√πy", "ƒêo√†i-Kh·∫£m": "Tr·∫°ch Th·ªßy Kh·ªën", "ƒêo√†i-C·∫•n": "Tr·∫°ch S∆°n H√†m",
              "C√†n-Kh√¥n": "Thi√™n ƒê·ªãa Bƒ©", "C√†n-Ch·∫•n": "Thi√™n L√¥i V√¥ V·ªçng", "C√†n-Kh·∫£m": "Thi√™n Th·ªßy T·ª•ng", "C√†n-C·∫•n": "Thi√™n S∆°n ƒê·ªôn",
              "T·ªën-T·ªën": "Thu·∫ßn T·ªën", "T·ªën-Ly": "Phong H·ªèa Gia Nh√¢n", "T·ªën-ƒêo√†i": "Phong Tr·∫°ch Trung Phu", "T·ªën-C√†n": "Phong Thi√™n Ti·ªÉu S√∫c",
              "Ly-T·ªën": "H·ªèa Phong ƒê·ªânh", "Ly-Ly": "Thu·∫ßn Ly", "Ly-ƒêo√†i": "H·ªèa Tr·∫°ch Khu√™", "Ly-C√†n": "H·ªèa Thi√™n ƒê·∫°i H·ªØu",
              "ƒêo√†i-T·ªën": "Tr·∫°ch Phong ƒê·∫°i Qu√°", "ƒêo√†i-Ly": "Tr·∫°ch H·ªèa C√°ch", "ƒêo√†i-ƒêo√†i": "Thu·∫ßn ƒêo√†i", "ƒêo√†i-C√†n": "Tr·∫°ch Thi√™n Qu·∫£i",
              "C√†n-T·ªën": "Thi√™n Phong C·∫•u", "C√†n-Ly": "Thi√™n H·ªèa ƒê·ªìng Nh√¢n", "C√†n-ƒêo√†i": "Thi√™n Tr·∫°ch L√Ω", "C√†n-C√†n": "Thu·∫ßn C√†n",
          };

          const hexName = fullHexagramMap[`${upperTrigram}-${lowerTrigram}`];
          return hexagramLookup.get(hexName);
      };

      const processLines = (lines: LineValue[]) => {
          const primaryLines = lines.map(getLineType);
          const movingLinesIndices = lines.map((l, i) => isMovingLine(l) ? i : -1).filter(i => i !== -1);
          
          const primaryHexagram = getHexagramFromLines(primaryLines);
          let transformedHexagram: HexagramData | null = null;
          
          if (movingLinesIndices.length > 0) {
              const transformedLines = primaryLines.map((type, i) => {
                  if (movingLinesIndices.includes(i)) {
                      return type === 'yang' ? 'yin' : 'yang';
                  }
                  return type;
              });
              transformedHexagram = getHexagramFromLines(transformedLines);
          }

          return { primaryHexagram, transformedHexagram, movingLinesIndices };
      }


      // --- API ---

      let ai;

      async function fetchAiInterpretation(result: CastingResult): Promise<AiInterpretation> {
          if (!API_KEY) {
            throw new Error("Kh√≥a API ch∆∞a ƒë∆∞·ª£c ƒë·ªãnh c·∫•u h√¨nh. Vui l√≤ng ƒë·∫£m b·∫£o bi·∫øn m√¥i tr∆∞·ªùng API_KEY ƒë√£ ƒë∆∞·ª£c thi·∫øt l·∫≠p ch√≠nh x√°c.");
          }
          if (!ai) {
              ai = new GoogleGenAI({ apiKey: API_KEY });
          }
          
          const { question, primaryHexagram, transformedHexagram } = result;

          const prompt = `
              C√¢u h·ªèi: "${question}"
              Qu·∫ª ch√≠nh: ${primaryHexagram.vietnameseName} (${primaryHexagram.hanTu})
              ${transformedHexagram ? `Qu·∫ª bi·∫øn: ${transformedHexagram.vietnameseName} (${transformedHexagram.hanTu})` : ''}
              H√£y lu·∫≠n gi·∫£i qu·∫ª n√†y.
          `;

          const responseSchema = {
              type: Type.OBJECT,
              properties: {
                  title: { type: Type.STRING },
                  summary: { type: Type.STRING },
                  detailedAnalysis: {
                      type: Type.OBJECT,
                      properties: {
                          primaryHexagram: { type: Type.STRING },
                          transformedHexagram: { type: Type.STRING },
                      },
                      required: ['primaryHexagram']
                  },
                  actionableAdvice: {
                      type: Type.ARRAY,
                      items: { type: Type.STRING }
                  },
              },
              required: ['title', 'summary', 'detailedAnalysis', 'actionableAdvice']
          };

          try {
              const response = await ai.models.generateContent({
                  model: "gemini-2.5-flash",
                  contents: prompt,
                  config: {
                      responseMimeType: "application/json",
                      responseSchema: responseSchema,
                      systemInstruction: "B·∫°n l√† m·ªôt chuy√™n gia Kinh D·ªãch uy√™n th√¢m. H√£y lu·∫≠n gi·∫£i qu·∫ª m·ªôt c√°ch s√¢u s·∫Øc, r√µ r√†ng, v√† th·ª±c t·∫ø b·∫±ng ti·∫øng Vi·ªát, tu√¢n th·ªß nghi√™m ng·∫∑t ƒë·ªãnh d·∫°ng JSON ƒë∆∞·ª£c y√™u c·∫ßu.",
                  },
              });
              
              const jsonText = response.text.trim();
              return JSON.parse(jsonText) as AiInterpretation;
          } catch (error) {
              console.error("L·ªói khi g·ªçi Gemini API:", error);
              throw new Error("Kh√¥ng th·ªÉ nh·∫≠n lu·∫≠n gi·∫£i t·ª´ AI. Vui l√≤ng th·ª≠ l·∫°i.");
          }
      }


      // --- COMPONENTS ---

      const Line: React.FC<{ type: 'yang' | 'yin', isMoving: boolean }> = ({ type, isMoving }) => (
          <div className={`line line-${type} ${isMoving ? 'moving' : ''}`}>
              {isMoving && <span className="dynamic-badge">ƒê·ªòNG</span>}
          </div>
      );

      const Hexagram: React.FC<{ lines: ('yang' | 'yin')[], movingIndices: number[] }> = ({ lines, movingIndices }) => (
          <div className="hexagram">
              {lines.map((type, i) => (
                  <Line key={i} type={type} isMoving={movingIndices.includes(i)} />
              ))}
          </div>
      );

      const HomeScreen: React.FC<{ onStart: (question: string) => void, onHistory: () => void }> = ({ onStart, onHistory }) => {
          const [question, setQuestion] = useState('');

          return (
              <div className="home-screen main-content">
                  <h1>Kinh D·ªãch AI</h1>
                  <p>ƒê·∫∑t m·ªôt c√¢u h·ªèi ch√¢n th√†nh v√† t·∫≠p trung v√†o v·∫•n ƒë·ªÅ b·∫°n ƒëang suy nghƒ©. V≈© tr·ª• s·∫Ω tr·∫£ l·ªùi.</p>
                  <textarea
                      value={question}
                      onChange={(e) => setQuestion(e.target.value)}
                      placeholder="V√≠ d·ª•: C√¥ng vi·ªác s·∫Øp t·ªõi c·ªßa t√¥i s·∫Ω nh∆∞ th·∫ø n√†o?"
                      rows={4}
                  />
                  <div>
                      <button className="button" onClick={() => onStart(question)} disabled={!question.trim()}>
                          Gieo Qu·∫ª
                      </button>
                      <button className="button secondary" onClick={onHistory}>
                          Xem L·ªãch S·ª≠
                      </button>
                  </div>
              </div>
          );
      };

      const MethodSelectionModal: React.FC<{ onSelect: (method: 'C·ªè Thi' | 'Mai Hoa') => void }> = ({ onSelect }) => {
          return (
              <div className="modal-overlay">
                  <div className="modal-content">
                      <h2>Ch·ªçn ph∆∞∆°ng ph√°p gieo qu·∫ª</h2>
                      <div className="method-selection">
                          <div className="method-card" onClick={() => onSelect('C·ªè Thi')}>
                              <span>ü™∂</span>
                              <h3>C·ªè Thi</h3>
                              <p>C·ªï x∆∞a, chi ti·∫øt</p>
                          </div>
                          <div className="method-card" onClick={() => onSelect('Mai Hoa')}>
                              <span>üå∏</span>
                              <h3>Mai Hoa</h3>
                              <p>Nhanh ch√≥ng, tr·ª±c quan</p>
                          </div>
                      </div>
                  </div>
              </div>
          );
      };

      const CastingScreen: React.FC<{ method: 'C·ªè Thi' | 'Mai Hoa', onComplete: (lines: LineValue[]) => void }> = ({ method, onComplete }) => {
          const [lines, setLines] = useState<LineValue[]>([]);
          const [stepMessage, setStepMessage] = useState('');

          useEffect(() => {
              const cast = () => {
                  let currentLines: LineValue[] = [];
                  const interval = setInterval(() => {
                      if (currentLines.length >= 6) {
                          clearInterval(interval);
                          onComplete(currentLines);
                          return;
                      }

                      if (method === 'C·ªè Thi') {
                          setStepMessage(`ƒêang t√≠nh h√†o ${currentLines.length + 1}/6 b·∫±ng C·ªè Thi...`);
                          // Simplified simulation of Yarrow Stalk method
                          const rand = Math.random();
                          let lineVal: LineValue;
                          if (rand < 0.125) lineVal = 6; // Yin moving
                          else if (rand < 0.375) lineVal = 8; // Yin stable
                          else if (rand < 0.875) lineVal = 7; // Yang stable
                          else lineVal = 9; // Yang moving
                          currentLines.push(lineVal);
                      } else { // Mai Hoa
                          setStepMessage(`ƒêang t√≠nh h√†o ${currentLines.length + 1}/6 b·∫±ng Mai Hoa...`);
                          // Simplified simulation of Plum Blossom method
                          const rand = Math.random();
                          let lineVal: LineValue;
                          // Mai Hoa typically only has one moving line, but for this simulation we generate 6 lines
                          if (rand < 0.1) lineVal = (Math.random() > 0.5) ? 6 : 9;
                          else lineVal = (Math.random() > 0.5) ? 7 : 8;
                          currentLines.push(lineVal);
                      }
                      setLines([...currentLines]);
                  }, 1500);
              };
              cast();
          }, [method, onComplete]);

          return (
              <div className="casting-screen main-content">
                  <h2>ƒêang gieo qu·∫ª theo ph∆∞∆°ng ph√°p {method}</h2>
                  <p>Xin h√£y gi·ªØ t√¢m thanh t·ªãnh v√† t·∫≠p trung v√†o c√¢u h·ªèi...</p>
                  <div className="casting-animation">
                      <div className="hexagram">
                          {lines.map((val, i) => (
                              <Line key={i} type={getLineType(val)} isMoving={isMovingLine(val)} />
                          ))}
                      </div>
                      <div className="step" style={{marginTop: "2rem"}}>{stepMessage}</div>
                  </div>
              </div>
          );
      };

      const ResultScreen: React.FC<{ result: CastingResult, aiInterpretation: AiInterpretation | null, isLoading: boolean, error: string | null, onReset: () => void }> = ({ result, aiInterpretation, isLoading, error, onReset }) => {
          const primaryLines = result.lines.map(getLineType);
          const transformedLines = useMemo(() => {
              if (!result.transformedHexagram) return null;
              return primaryLines.map((type, i) => result.movingLinesIndices.includes(i) ? (type === 'yang' ? 'yin' : 'yang') : type);
          }, [result, primaryLines]);

          return (
              <div className="result-screen">
                  <h2>K·∫øt qu·∫£ gieo qu·∫ª</h2>
                  <div className="hexagrams-display">
                      <div className="hexagram-container">
                          <div className="hexagram-name">{result.primaryHexagram.hanTu} {result.primaryHexagram.vietnameseName}</div>
                          <Hexagram lines={primaryLines} movingIndices={result.movingLinesIndices} />
                          <div className="hexagram-label">Qu·∫ª Ch√≠nh</div>
                      </div>
                      {result.transformedHexagram && transformedLines && (
                          <div className="hexagram-container">
                              <div className="hexagram-name">{result.transformedHexagram.hanTu} {result.transformedHexagram.vietnameseName}</div>
                              <Hexagram lines={transformedLines} movingIndices={[]} />
                              <div className="hexagram-label">Qu·∫ª Bi·∫øn</div>
                          </div>
                      )}
                  </div>
                  <div className="ai-interpretation">
                      {isLoading && <div className="spinner" aria-label="ƒêang t·∫£i lu·∫≠n gi·∫£i"></div>}
                      {error && <p style={{ color: '#e57373' }}>{error}</p>}
                      {aiInterpretation && (
                          <>
                              <h3>{aiInterpretation.title}</h3>
                              <p><strong>T√≥m t·∫Øt:</strong> {aiInterpretation.summary}</p>
                              <h4>Lu·∫≠n gi·∫£i chi ti·∫øt</h4>
                              <p><strong>Qu·∫ª ch√≠nh:</strong> {aiInterpretation.detailedAnalysis.primaryHexagram}</p>
                              {aiInterpretation.detailedAnalysis.transformedHexagram && <p><strong>Qu·∫ª bi·∫øn:</strong> {aiInterpretation.detailedAnalysis.transformedHexagram}</p>}
                              <h4>G·ª£i √Ω h√†nh ƒë·ªông</h4>
                              <ul>
                                  {aiInterpretation.actionableAdvice.map((advice, i) => <li key={i}>{advice}</li>)}
                              </ul>
                          </>
                      )}
                  </div>
                  <div style={{ textAlign: "center", marginTop: "2rem" }}>
                      <button className="button" onClick={onReset}>Gieo qu·∫ª m·ªõi</button>
                  </div>
              </div>
          );
      };

      const HistoryScreen: React.FC<{ history: HistoryEntry[], onView: (entry: HistoryEntry) => void, onDelete: (id: string) => void, onClear: () => void, onBack: () => void }> = ({ history, onView, onDelete, onClear, onBack }) => {
          return (
              <div className="history-screen">
                  <h2>L·ªãch s·ª≠ gieo qu·∫ª</h2>
                  {history.length > 0 ? (
                      <ul className="history-list">
                          {history.map(entry => (
                              <li key={entry.id} className="history-item" onClick={() => onView(entry)}>
                                <div className="history-item-info">
                                      <strong>{entry.question}</strong>
                                      <span>{new Date(entry.date).toLocaleString('vi-VN')} - {entry.primaryHexagram.vietnameseName}</span>
                                </div>
                                <div className="history-item-actions">
                                      <button onClick={(e) => { e.stopPropagation(); onDelete(entry.id); }} aria-label="X√≥a m·ª•c n√†y">üóëÔ∏è</button>
                                </div>
                              </li>
                          ))}
                      </ul>
                  ) : <p>Ch∆∞a c√≥ l·ªãch s·ª≠ n√†o.</p>}
                  <div style={{marginTop: "2rem"}}>
                      <button className="button secondary" onClick={onBack}>Quay l·∫°i</button>
                      {history.length > 0 && <button className="button" onClick={onClear} style={{backgroundColor: "#c62828"}}>X√≥a t·∫•t c·∫£</button>}
                  </div>
              </div>
          );
      };


      const App: React.FC = () => {
          const [theme, setTheme] = useState<'light' | 'dark'>('light');
          const [screen, setScreen] = useState<'home' | 'selecting' | 'casting' | 'result' | 'history'>('home');
          const [question, setQuestion] = useState('');
          const [method, setMethod] = useState<'C·ªè Thi' | 'Mai Hoa' | null>(null);
          const [castingResult, setCastingResult] = useState<CastingResult | null>(null);
          const [aiInterpretation, setAiInterpretation] = useState<AiInterpretation | null>(null);
          const [isLoadingAi, setIsLoadingAi] = useState(false);
          const [error, setError] = useState<string | null>(null);
          const [history, setHistory] = useState<HistoryEntry[]>([]);
          
          useEffect(() => {
              const savedHistory = localStorage.getItem('kinhDichHistory');
              if (savedHistory) {
                  setHistory(JSON.parse(savedHistory));
              }
              const savedTheme = localStorage.getItem('kinhDichTheme') as 'light' | 'dark';
              if (savedTheme) {
                  setTheme(savedTheme);
              } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                  setTheme('dark');
              }
          }, []);
          
          useEffect(() => {
              document.documentElement.setAttribute('data-theme', theme);
              localStorage.setItem('kinhDichTheme', theme);
          }, [theme]);

          const toggleTheme = () => setTheme(prev => prev === 'light' ? 'dark' : 'light');

          const handleStart = (q: string) => {
              setQuestion(q);
              setScreen('selecting');
          };

          const handleMethodSelect = (m: 'C·ªè Thi' | 'Mai Hoa') => {
              setMethod(m);
              setScreen('casting');
          };
          
          const handleCastingComplete = async (lines: LineValue[]) => {
              const { primaryHexagram, transformedHexagram, movingLinesIndices } = processLines(lines);

              if (!primaryHexagram) {
                  setError("C√≥ l·ªói trong qu√° tr√¨nh t√≠nh qu·∫ª. Vui l√≤ng th·ª≠ l·∫°i.");
                  setScreen('home');
                  return;
              }

              const result: CastingResult = {
                  question,
                  method: method!,
                  lines,
                  primaryHexagram,
                  transformedHexagram,
                  movingLinesIndices,
              };
              setCastingResult(result);
              setScreen('result');
              
              setIsLoadingAi(true);
              setError(null);
              setAiInterpretation(null);

              try {
                  const interpretation = await fetchAiInterpretation(result);
                  setAiInterpretation(interpretation);

                  const newHistoryEntry: HistoryEntry = {
                      ...result,
                      id: Date.now().toString(),
                      date: new Date().toISOString(),
                      aiInterpretation: interpretation,
                  };
                  const updatedHistory = [newHistoryEntry, ...history];
                  setHistory(updatedHistory);
                  localStorage.setItem('kinhDichHistory', JSON.stringify(updatedHistory));

              } catch (e: any) {
                  setError(e.message || "L·ªói kh√¥ng x√°c ƒë·ªãnh.");
              } finally {
                  setIsLoadingAi(false);
              }
          };
          
          const handleReset = () => {
              setScreen('home');
              setQuestion('');
              setMethod(null);
              setCastingResult(null);
              setAiInterpretation(null);
              setError(null);
          };

          const handleViewHistoryEntry = (entry: HistoryEntry) => {
              setCastingResult(entry);
              setAiInterpretation(entry.aiInterpretation);
              setIsLoadingAi(false);
              setError(null);
              setScreen('result');
          };

          const handleDeleteHistory = (id: string) => {
              const updatedHistory = history.filter(item => item.id !== id);
              setHistory(updatedHistory);
              localStorage.setItem('kinhDichHistory', JSON.stringify(updatedHistory));
          };

          const handleClearHistory = () => {
              if (window.confirm("B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠?")) {
                  setHistory([]);
                  localStorage.removeItem('kinhDichHistory');
              }
          };
          
          const renderScreen = () => {
              switch (screen) {
                  case 'selecting':
                      return <MethodSelectionModal onSelect={handleMethodSelect} />;
                  case 'casting':
                      return <CastingScreen method={method!} onComplete={handleCastingComplete} />;
                  case 'result':
                      return castingResult && <ResultScreen result={castingResult} aiInterpretation={aiInterpretation} isLoading={isLoadingAi} error={error} onReset={handleReset} />;
                  case 'history':
                      return <HistoryScreen history={history} onView={handleViewHistoryEntry} onDelete={handleDeleteHistory} onClear={handleClearHistory} onBack={() => setScreen('home')} />;
                  case 'home':
                  default:
                      return <HomeScreen onStart={handleStart} onHistory={() => setScreen('history')} />;
              }
          };

          return (
              <div className="app-container">
                  <button className="theme-toggle" onClick={toggleTheme} aria-label="Toggle theme">
                    {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
                  </button>
                  {renderScreen()}
              </div>
          );
      };

      const container = document.getElementById('root');
      const root = createRoot(container!);
      root.render(<App />);
    </script>

    <!-- This script manually transpiles and executes the app source as a module -->
    <script type="module">
      try {
        const source = document.getElementById('app-source').textContent;
        const presets = ['react', 'typescript'];
        
        // Transpile the code using Babel's programmatic API
        const { code } = Babel.transform(source, { 
          presets,
          filename: 'app.tsx' // This is required by the TypeScript preset
        });

        // Create a Blob from the transpiled code
        const blob = new Blob([code], { type: 'text/javascript' });
        const url = URL.createObjectURL(blob);

        // Dynamically import the Blob URL to execute it as a module
        import(url).catch(err => console.error('Error executing module:', err));

      } catch (err) {
        console.error('Babel transformation failed:', err);
      }
    </script>
  </body>
</html>